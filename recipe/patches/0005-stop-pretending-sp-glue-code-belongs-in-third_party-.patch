From 60017d890e3f1211cea3b00120e2498f4755d01d Mon Sep 17 00:00:00 2001
From: "H. Vetinari" <h.vetinari@gmx.com>
Date: Mon, 21 Feb 2022 12:50:47 +1100
Subject: [PATCH 5/8] stop pretending sp glue code belongs in third_party/absl

---
 src/CMakeLists.txt                            |   4 +-
 src/bpe_model_trainer_test.cc                 |  11 +-
 src/builder_test.cc                           |  15 +-
 src/char_model_trainer_test.cc                |   5 +-
 src/compile_charsmap_main.cc                  |   6 +-
 src/error.cc                                  |   9 --
 src/filesystem_test.cc                        |   5 +-
 {third_party/absl => src/glue}/flags/flag.cc  |  22 +--
 {third_party/absl => src/glue}/flags/flag.h   |  18 +--
 {third_party/absl => src/glue}/flags/parse.h  |  10 +-
 .../absl => src/glue}/random/distributions.h  |   4 +-
 .../absl => src/glue}/random/random.h         |   6 +-
 src/init.h                                    |  15 +-
 src/init_test.cc                              |  61 ++++----
 src/sentencepiece_processor_test.cc           |   9 +-
 src/sentencepiece_trainer_test.cc             |  27 ++--
 src/spm_decode_main.cc                        |  43 +++---
 src/spm_encode_main.cc                        |  74 +++++-----
 src/spm_export_vocab_main.cc                  |  19 ++-
 src/spm_normalize_main.cc                     |  45 +++---
 src/spm_train_main.cc                         | 138 +++++++++---------
 src/test_main.cc                              |   7 +-
 src/testharness.cc                            |   5 +-
 src/testharness.h                             |   8 +-
 src/trainer_interface.cc                      |  10 +-
 src/trainer_interface_test.cc                 |   7 +-
 src/unigram_model_trainer_test.cc             |  11 +-
 src/util_test.cc                              |   5 +-
 src/word_model_trainer_test.cc                |   5 +-
 29 files changed, 304 insertions(+), 300 deletions(-)
 rename {third_party/absl => src/glue}/flags/flag.cc (94%)
 rename {third_party/absl => src/glue}/flags/flag.h (77%)
 rename {third_party/absl => src/glue}/flags/parse.h (79%)
 rename {third_party/absl => src/glue}/random/distributions.h (94%)
 rename {third_party/absl => src/glue}/random/random.h (91%)

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index d30a4c2..c130e8b 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -13,7 +13,9 @@
 # limitations under the License.!
 
 if (SPM_USE_EXTERNAL_ABSL)
-  set(ABSL_FLAGS_SRCS "")
+  # originally part of third_party/absl, but actually
+  # only relevant for sentencepiece; now moved.
+  set(ABSL_FLAGS_SRCS "glue/flags/flag.cc")
   set(ABSL_STRINGS_SRCS "")
   list(APPEND SPM_LIBS absl::strings)
   list(APPEND SPM_LIBS absl::flags)
diff --git a/src/bpe_model_trainer_test.cc b/src/bpe_model_trainer_test.cc
index f977fd0..67b5b2d 100644
--- a/src/bpe_model_trainer_test.cc
+++ b/src/bpe_model_trainer_test.cc
@@ -20,6 +20,7 @@
 
 #include "bpe_model_trainer.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "sentencepiece_processor.h"
 #include "sentencepiece_trainer.h"
 #include "testharness.h"
@@ -36,9 +37,9 @@ std::string RunTrainer(
     const std::vector<std::string> &input, int size,
     const std::vector<std::string> &user_defined_symbols = {}) {
   const std::string input_file =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "input");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "input");
   const std::string model_prefix =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "model");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "model");
   {
     auto output = filesystem::NewWritableFile(input_file);
     for (const auto &line : input) {
@@ -94,13 +95,13 @@ static constexpr char kTestInputData[] = "wagahaiwa_nekodearu.txt";
 
 TEST(BPETrainerTest, EndToEndTest) {
   const std::string input =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestInputData);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestInputData);
 
   ASSERT_TRUE(
       SentencePieceTrainer::Train(
           absl::StrCat(
               "--model_prefix=",
-              util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "tmp_model"),
+              util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "tmp_model"),
               " --input=", input,
               " --vocab_size=8000 --normalization_rule_name=identity"
               " --model_type=bpe --control_symbols=<ctrl> "
@@ -109,7 +110,7 @@ TEST(BPETrainerTest, EndToEndTest) {
 
   SentencePieceProcessor sp;
   ASSERT_TRUE(sp.Load(std::string(util::JoinPath(
-                          absl::GetFlag(FLAGS_test_tmpdir), "tmp_model.model")))
+                          sentencepiece::GetFlag(FLAGS_test_tmpdir), "tmp_model.model")))
                   .ok());
   EXPECT_EQ(8000, sp.GetPieceSize());
 
diff --git a/src/builder_test.cc b/src/builder_test.cc
index f586fba..c6e6344 100644
--- a/src/builder_test.cc
+++ b/src/builder_test.cc
@@ -17,6 +17,7 @@
 #include "builder.h"
 #include "common.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "normalizer.h"
 #include "sentencepiece_trainer.h"
 #include "testharness.h"
@@ -144,7 +145,7 @@ TEST(BuilderTest, LoadCharsMapTest) {
   Builder::CharsMap chars_map;
   ASSERT_TRUE(
       Builder::LoadCharsMap(
-          util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestInputData),
+          util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestInputData),
           &chars_map)
           .ok());
 
@@ -159,14 +160,14 @@ TEST(BuilderTest, LoadCharsMapTest) {
 
   ASSERT_TRUE(
       Builder::SaveCharsMap(
-          util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "output.tsv"),
+          util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "output.tsv"),
           chars_map)
           .ok());
 
   Builder::CharsMap saved_chars_map;
   ASSERT_TRUE(
       Builder::LoadCharsMap(
-          util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "output.tsv"),
+          util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "output.tsv"),
           &saved_chars_map)
           .ok());
   EXPECT_EQ(chars_map, saved_chars_map);
@@ -181,7 +182,7 @@ TEST(BuilderTest, LoadCharsMapTest) {
 TEST(BuilderTest, LoadCharsMapWithEmptyeTest) {
   {
     auto output = filesystem::NewWritableFile(
-        util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test.tsv"));
+        util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test.tsv"));
     output->WriteLine("0061\t0041");
     output->WriteLine("0062");
     output->WriteLine("0063\t\t#foo=>bar");
@@ -189,7 +190,7 @@ TEST(BuilderTest, LoadCharsMapWithEmptyeTest) {
 
   Builder::CharsMap chars_map;
   EXPECT_TRUE(Builder::LoadCharsMap(
-                  util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test.tsv"),
+                  util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test.tsv"),
                   &chars_map)
                   .ok());
 
@@ -200,14 +201,14 @@ TEST(BuilderTest, LoadCharsMapWithEmptyeTest) {
 
   EXPECT_TRUE(
       Builder::SaveCharsMap(
-          util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test_out.tsv"),
+          util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test_out.tsv"),
           chars_map)
           .ok());
 
   Builder::CharsMap new_chars_map;
   EXPECT_TRUE(
       Builder::LoadCharsMap(
-          util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test_out.tsv"),
+          util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test_out.tsv"),
           &new_chars_map)
           .ok());
   EXPECT_EQ(chars_map, new_chars_map);
diff --git a/src/char_model_trainer_test.cc b/src/char_model_trainer_test.cc
index b49cea1..7192b68 100644
--- a/src/char_model_trainer_test.cc
+++ b/src/char_model_trainer_test.cc
@@ -20,6 +20,7 @@
 
 #include "char_model_trainer.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "sentencepiece_processor.h"
 #include "testharness.h"
 #include "util.h"
@@ -33,9 +34,9 @@ namespace {
 
 std::string RunTrainer(const std::vector<std::string> &input, int size) {
   const std::string input_file =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "input");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "input");
   const std::string model_prefix =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "model");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "model");
   {
     auto output = filesystem::NewWritableFile(input_file);
     for (const auto &line : input) {
diff --git a/src/compile_charsmap_main.cc b/src/compile_charsmap_main.cc
index 23e5ef8..88c217a 100644
--- a/src/compile_charsmap_main.cc
+++ b/src/compile_charsmap_main.cc
@@ -18,17 +18,17 @@
 #include <sstream>
 #include <string>
 
-#include "absl/flags/flag.h"
 #include "absl/strings/string_view.h"
 
 #include "builder.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "sentencepiece_processor.h"
 
 using sentencepiece::normalizer::Builder;
 
-ABSL_FLAG(bool, output_precompiled_header, false,
+STPC_FLAG(bool, output_precompiled_header, false,
           "make normalization_rule.h file");
 
 namespace sentencepiece {
@@ -187,7 +187,7 @@ int main(int argc, char **argv) {
     data.emplace_back(p.first, index);
   }
 
-  if (absl::GetFlag(FLAGS_output_precompiled_header)) {
+  if (sentencepiece::GetFlag(FLAGS_output_precompiled_header)) {
     constexpr char kPrecompiledHeaderFileName[] = "normalization_rule.h";
     auto output =
         sentencepiece::filesystem::NewWritableFile(kPrecompiledHeaderFileName);
diff --git a/src/error.cc b/src/error.cc
index 19ef6f3..e30f914 100644
--- a/src/error.cc
+++ b/src/error.cc
@@ -18,15 +18,6 @@
 #include "init.h"
 #include "sentencepiece_processor.h"
 
-#ifdef _USE_EXTERNAL_ABSL
-// Naive workaround to define minloglevel on external absl package.
-// We want to define them in other cc file.
-#include "absl/flags/flag.h"
-#include "absl/flags/parse.h"
-ABSL_FLAG(int32, minloglevel, 0,
-          "Messages logged at a lower level than this don't actually.");
-#endif
-
 namespace sentencepiece {
 namespace error {
 int gTestCounter = 0;
diff --git a/src/filesystem_test.cc b/src/filesystem_test.cc
index 3c9fbdc..305cd87 100644
--- a/src/filesystem_test.cc
+++ b/src/filesystem_test.cc
@@ -15,6 +15,7 @@
 #include "absl/strings/str_cat.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "testharness.h"
 #include "util.h"
 
@@ -29,7 +30,7 @@ TEST(UtilTest, FilesystemTest) {
 
   {
     auto output = filesystem::NewWritableFile(
-        util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test_file"));
+        util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test_file"));
     for (size_t i = 0; i < kData.size(); ++i) {
       output->WriteLine(kData[i]);
     }
@@ -37,7 +38,7 @@ TEST(UtilTest, FilesystemTest) {
 
   {
     auto input = filesystem::NewReadableFile(
-        util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test_file"));
+        util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test_file"));
     std::string line;
     for (size_t i = 0; i < kData.size(); ++i) {
       EXPECT_TRUE(input->ReadLine(&line));
diff --git a/third_party/absl/flags/flag.cc b/src/glue/flags/flag.cc
similarity index 94%
rename from third_party/absl/flags/flag.cc
rename to src/glue/flags/flag.cc
index 5d6642a..06aeb7e 100644
--- a/third_party/absl/flags/flag.cc
+++ b/src/glue/flags/flag.cc
@@ -12,25 +12,25 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.!
 
-#include "third_party/absl/flags/flag.h"
-
 #include <algorithm>
 #include <iostream>
 #include <map>
 #include <sstream>
 #include <string>
 
+#include "flag.h"
+
 #include "config.h"
-#include "src/common.h"
-#include "src/util.h"
+#include "../../common.h"
+#include "../../util.h"
 
-ABSL_FLAG(bool, help, false, "show help");
-ABSL_FLAG(bool, version, false, "show version");
-ABSL_FLAG(int, minloglevel, 0,
+STPC_FLAG(bool, help, false, "show help");
+STPC_FLAG(bool, version, false, "show version");
+STPC_FLAG(int, minloglevel, 0,
           "Messages logged at a lower level than this don't actually get "
           "logged anywhere");
 
-namespace absl {
+namespace sentencepiece {
 namespace internal {
 namespace {
 template <typename T>
@@ -209,10 +209,10 @@ std::vector<char *> ParseCommandLine(int argc, char *argv[]) {
     }
   }
 
-  if (absl::GetFlag(FLAGS_help)) {
+  if (sentencepiece::GetFlag(FLAGS_help)) {
     std::cout << internal::PrintHelp(argv[0]);
     sentencepiece::error::Exit(0);
-  } else if (absl::GetFlag(FLAGS_version)) {
+  } else if (sentencepiece::GetFlag(FLAGS_version)) {
     std::cout << PACKAGE_STRING << " " << VERSION << std::endl;
     sentencepiece::error::Exit(0);
   }
@@ -229,4 +229,4 @@ void CleanupFlags() {
   }
 }
 
-}  // namespace absl
+}  // namespace sentencepiece
diff --git a/third_party/absl/flags/flag.h b/src/glue/flags/flag.h
similarity index 77%
rename from third_party/absl/flags/flag.h
rename to src/glue/flags/flag.h
index c522358..ba439fe 100644
--- a/third_party/absl/flags/flag.h
+++ b/src/glue/flags/flag.h
@@ -12,15 +12,15 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.!
 
-#ifndef ABSL_FLAGS_FLAG_H_
-#define ABSL_FLAGS_FLAG_H_
+#ifndef SENTENCEPIECE_FLAG_H_
+#define SENTENCEPIECE_FLAG_H_
 
 #include <functional>
 #include <memory>
 #include <string>
 #include <vector>
 
-namespace absl {
+namespace sentencepiece {
 namespace internal {
 struct FlagFunc;
 
@@ -54,15 +54,15 @@ void SetFlag(Flag<T> *flag, const V &v) {
   flag->set_value(value);
 }
 
-#define HAS_ABSL_CLEANUP_FLAGS
+#define HAS_STPC_CLEANUP_FLAGS
 
 void CleanupFlags();
 
-}  // namespace absl
+}  // namespace sentencepiece
 
-#define ABSL_FLAG(Type, name, defautl_value, help) \
-  absl::Flag<Type> FLAGS_##name(#name, #Type, help, defautl_value);
+#define STPC_FLAG(Type, name, default_value, help) \
+  sentencepiece::Flag<Type> FLAGS_##name(#name, #Type, help, default_value);
 
-#define ABSL_DECLARE_FLAG(Type, name) extern absl::Flag<Type> FLAGS_##name;
+#define STPC_DECLARE_FLAG(Type, name) extern sentencepiece::Flag<Type> FLAGS_##name;
 
-#endif  // ABSL_FLAGS_FLAG_H_
+#endif  // SENTENCEPIECE_FLAG_H_
diff --git a/third_party/absl/flags/parse.h b/src/glue/flags/parse.h
similarity index 79%
rename from third_party/absl/flags/parse.h
rename to src/glue/flags/parse.h
index 6a06e63..705eadf 100644
--- a/third_party/absl/flags/parse.h
+++ b/src/glue/flags/parse.h
@@ -12,14 +12,14 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.!
 
-#ifndef ABSL_FLAGS_PARSE_H_
-#define ABSL_FLAGS_PARSE_H_
+#ifndef SENTENCEPIECE_FLAGS_PARSE_H_
+#define SENTENCEPIECE_FLAGS_PARSE_H_
 
 #include <vector>
 
-namespace absl {
+namespace sentencepiece {
 
 std::vector<char *> ParseCommandLine(int argc, char *argv[]);
-}  // namespace absl
+}  // namespace sentencepiece
 
-#endif  // ABSL_FLAGS_PARSE_H_
+#endif  // SENTENCEPIECE_FLAGS_PARSE_H_
diff --git a/third_party/absl/random/distributions.h b/src/glue/random/distributions.h
similarity index 94%
rename from third_party/absl/random/distributions.h
rename to src/glue/random/distributions.h
index 246ecb2..09bb838 100644
--- a/third_party/absl/random/distributions.h
+++ b/src/glue/random/distributions.h
@@ -19,13 +19,13 @@
 
 #include "random.h"
 
-namespace absl {
+namespace sentencepiece {
 
 template <typename T>
 T Gaussian(SharedBitGen &generator, T mean, T stddev) {
   std::normal_distribution<> dist(mean, stddev);
   return dist(*generator.engine());
 }
-}  // namespace absl
+}  // namespace sentencepiece
 
 #endif  // ABSL_CONTAINER_DISTRIBUTIONS_H_
diff --git a/third_party/absl/random/random.h b/src/glue/random/random.h
similarity index 91%
rename from third_party/absl/random/random.h
rename to src/glue/random/random.h
index 3c3a21e..ac20d33 100644
--- a/third_party/absl/random/random.h
+++ b/src/glue/random/random.h
@@ -17,17 +17,17 @@
 
 #include <random>
 
-#include "../../../src/util.h"
+#include "../../util.h"
 
 using sentencepiece::random::GetRandomGenerator;
 
-namespace absl {
+namespace sentencepiece {
 
 class SharedBitGen {
  public:
   std::mt19937 *engine() { return GetRandomGenerator(); }
 };
 
-}  // namespace absl
+}  // namespace sentencepiece
 
 #endif  // ABSL_CONTAINER_RANDOM_H_
diff --git a/src/init.h b/src/init.h
index 1f4c292..ec4e4be 100644
--- a/src/init.h
+++ b/src/init.h
@@ -15,10 +15,9 @@
 #ifndef INIT_H_
 #define INIT_H_
 
-#include "absl/flags/flag.h"
-#include "absl/flags/parse.h"
-
 #include "common.h"
+#include "glue/flags/flag.h"
+#include "glue/flags/parse.h"
 
 #ifdef _USE_EXTERNAL_PROTOBUF
 #include "google/protobuf/message_lite.h"
@@ -26,12 +25,12 @@
 #include "third_party/protobuf-lite/google/protobuf/message_lite.h"
 #endif
 
-ABSL_DECLARE_FLAG(int32, minloglevel);
+STPC_DECLARE_FLAG(int32, minloglevel);
 
 namespace sentencepiece {
 inline void ParseCommandLineFlags(const char *usage, int *argc, char ***argv,
                                   bool remove_arg = true) {
-  const auto unused_args = absl::ParseCommandLine(*argc, *argv);
+  const auto unused_args = sentencepiece::ParseCommandLine(*argc, *argv);
 
   if (remove_arg) {
     char **argv_val = *argv;
@@ -40,13 +39,13 @@ inline void ParseCommandLineFlags(const char *usage, int *argc, char ***argv,
     *argc = static_cast<int>(unused_args.size());
   }
 
-  logging::SetMinLogLevel(absl::GetFlag(FLAGS_minloglevel));
+  logging::SetMinLogLevel(sentencepiece::GetFlag(FLAGS_minloglevel));
 }
 
 inline void ShutdownLibrary() {
   google::protobuf::ShutdownProtobufLibrary();
-#ifdef HAS_ABSL_CLEANUP_FLAGS
-  absl::CleanupFlags();
+#ifdef HAS_STPC_CLEANUP_FLAGS
+  sentencepiece::CleanupFlags();
 #endif
 }
 
diff --git a/src/init_test.cc b/src/init_test.cc
index e5cd2e4..82381c2 100644
--- a/src/init_test.cc
+++ b/src/init_test.cc
@@ -15,28 +15,29 @@
 #include "init.h"
 
 #include "common.h"
+#include "glue/flags/flag.h"
 #include "testharness.h"
 
-ABSL_FLAG(int32, int32_f, 10, "int32_flags");
-ABSL_FLAG(bool, bool_f, false, "bool_flags");
-ABSL_FLAG(int64, int64_f, 9223372036854775807LL, "int64_flags");
-ABSL_FLAG(uint64, uint64_f, 18446744073709551615ULL, "uint64_flags");
-ABSL_FLAG(double, double_f, 40.0, "double_flags");
-ABSL_FLAG(std::string, string_f, "str", "string_flags");
+STPC_FLAG(int32, int32_f, 10, "int32_flags");
+STPC_FLAG(bool, bool_f, false, "bool_flags");
+STPC_FLAG(int64, int64_f, 9223372036854775807LL, "int64_flags");
+STPC_FLAG(uint64, uint64_f, 18446744073709551615ULL, "uint64_flags");
+STPC_FLAG(double, double_f, 40.0, "double_flags");
+STPC_FLAG(std::string, string_f, "str", "string_flags");
 
-ABSL_DECLARE_FLAG(bool, help);
-ABSL_DECLARE_FLAG(bool, version);
+STPC_DECLARE_FLAG(bool, help);
+STPC_DECLARE_FLAG(bool, version);
 
 using sentencepiece::ParseCommandLineFlags;
 
 namespace absl {
 TEST(FlagsTest, DefaultValueTest) {
-  EXPECT_EQ(10, absl::GetFlag(FLAGS_int32_f));
-  EXPECT_EQ(false, absl::GetFlag(FLAGS_bool_f));
-  EXPECT_EQ(9223372036854775807LL, absl::GetFlag(FLAGS_int64_f));
-  EXPECT_EQ(18446744073709551615ULL, absl::GetFlag(FLAGS_uint64_f));
-  EXPECT_EQ(40.0, absl::GetFlag(FLAGS_double_f));
-  EXPECT_EQ("str", absl::GetFlag(FLAGS_string_f));
+  EXPECT_EQ(10, sentencepiece::GetFlag(FLAGS_int32_f));
+  EXPECT_EQ(false, sentencepiece::GetFlag(FLAGS_bool_f));
+  EXPECT_EQ(9223372036854775807LL, sentencepiece::GetFlag(FLAGS_int64_f));
+  EXPECT_EQ(18446744073709551615ULL, sentencepiece::GetFlag(FLAGS_uint64_f));
+  EXPECT_EQ(40.0, sentencepiece::GetFlag(FLAGS_double_f));
+  EXPECT_EQ("str", sentencepiece::GetFlag(FLAGS_string_f));
 }
 
 TEST(FlagsTest, ParseCommandLineFlagsTest) {
@@ -48,12 +49,12 @@ TEST(FlagsTest, ParseCommandLineFlagsTest) {
   char **argv = const_cast<char **>(kFlags);
   ParseCommandLineFlags(kFlags[0], &argc, &argv);
 
-  EXPECT_EQ(100, absl::GetFlag(FLAGS_int32_f));
-  EXPECT_EQ(true, absl::GetFlag(FLAGS_bool_f));
-  EXPECT_EQ(200, absl::GetFlag(FLAGS_int64_f));
-  EXPECT_EQ(300, absl::GetFlag(FLAGS_uint64_f));
-  EXPECT_EQ(400.0, absl::GetFlag(FLAGS_double_f));
-  EXPECT_EQ("foo", absl::GetFlag(FLAGS_string_f));
+  EXPECT_EQ(100, sentencepiece::GetFlag(FLAGS_int32_f));
+  EXPECT_EQ(true, sentencepiece::GetFlag(FLAGS_bool_f));
+  EXPECT_EQ(200, sentencepiece::GetFlag(FLAGS_int64_f));
+  EXPECT_EQ(300, sentencepiece::GetFlag(FLAGS_uint64_f));
+  EXPECT_EQ(400.0, sentencepiece::GetFlag(FLAGS_double_f));
+  EXPECT_EQ("foo", sentencepiece::GetFlag(FLAGS_string_f));
   EXPECT_EQ(4, argc);
   EXPECT_EQ("program", std::string(argv[0]));
   EXPECT_EQ("other1", std::string(argv[1]));
@@ -69,10 +70,10 @@ TEST(FlagsTest, ParseCommandLineFlagsTest2) {
   char **argv = const_cast<char **>(kFlags);
   ParseCommandLineFlags(kFlags[0], &argc, &argv);
 
-  EXPECT_EQ(500, absl::GetFlag(FLAGS_int32_f));
-  EXPECT_EQ(600, absl::GetFlag(FLAGS_int64_f));
-  EXPECT_EQ(700, absl::GetFlag(FLAGS_uint64_f));
-  EXPECT_FALSE(absl::GetFlag(FLAGS_bool_f));
+  EXPECT_EQ(500, sentencepiece::GetFlag(FLAGS_int32_f));
+  EXPECT_EQ(600, sentencepiece::GetFlag(FLAGS_int64_f));
+  EXPECT_EQ(700, sentencepiece::GetFlag(FLAGS_uint64_f));
+  EXPECT_FALSE(sentencepiece::GetFlag(FLAGS_bool_f));
   EXPECT_EQ(1, argc);
 }
 
@@ -82,8 +83,8 @@ TEST(FlagsTest, ParseCommandLineFlagsTest3) {
   int argc = arraysize(kFlags);
   char **argv = const_cast<char **>(kFlags);
   ParseCommandLineFlags(kFlags[0], &argc, &argv);
-  EXPECT_TRUE(absl::GetFlag(FLAGS_bool_f));
-  EXPECT_EQ(800, absl::GetFlag(FLAGS_int32_f));
+  EXPECT_TRUE(sentencepiece::GetFlag(FLAGS_bool_f));
+  EXPECT_EQ(800, sentencepiece::GetFlag(FLAGS_int32_f));
   EXPECT_EQ(1, argc);
 }
 
@@ -94,7 +95,7 @@ TEST(FlagsTest, ParseCommandLineFlagsHelpTest) {
   int argc = arraysize(kFlags);
   char **argv = const_cast<char **>(kFlags);
   EXPECT_DEATH(ParseCommandLineFlags(kFlags[0], &argc, &argv), "");
-  absl::SetFlag(&FLAGS_help, false);
+  sentencepiece::SetFlag(&FLAGS_help, false);
 }
 
 TEST(FlagsTest, ParseCommandLineFlagsVersionTest) {
@@ -102,7 +103,7 @@ TEST(FlagsTest, ParseCommandLineFlagsVersionTest) {
   int argc = arraysize(kFlags);
   char **argv = const_cast<char **>(kFlags);
   EXPECT_DEATH(ParseCommandLineFlags(kFlags[0], &argc, &argv), "");
-  absl::SetFlag(&FLAGS_version, false);
+  sentencepiece::SetFlag(&FLAGS_version, false);
 }
 
 TEST(FlagsTest, ParseCommandLineFlagsUnknownTest) {
@@ -125,7 +126,7 @@ TEST(FlagsTest, ParseCommandLineFlagsEmptyStringArgs) {
   char **argv = const_cast<char **>(kFlags);
   ParseCommandLineFlags(kFlags[0], &argc, &argv);
   EXPECT_EQ(1, argc);
-  EXPECT_EQ("", absl::GetFlag(FLAGS_string_f));
+  EXPECT_EQ("", sentencepiece::GetFlag(FLAGS_string_f));
 }
 
 TEST(FlagsTest, ParseCommandLineFlagsEmptyBoolArgs) {
@@ -134,7 +135,7 @@ TEST(FlagsTest, ParseCommandLineFlagsEmptyBoolArgs) {
   char **argv = const_cast<char **>(kFlags);
   ParseCommandLineFlags(kFlags[0], &argc, &argv);
   EXPECT_EQ(1, argc);
-  EXPECT_TRUE(absl::GetFlag(FLAGS_bool_f));
+  EXPECT_TRUE(sentencepiece::GetFlag(FLAGS_bool_f));
 }
 
 TEST(FlagsTest, ParseCommandLineFlagsEmptyIntArgs) {
diff --git a/src/sentencepiece_processor_test.cc b/src/sentencepiece_processor_test.cc
index 4077c65..208b92f 100644
--- a/src/sentencepiece_processor_test.cc
+++ b/src/sentencepiece_processor_test.cc
@@ -23,6 +23,7 @@
 
 #include "builder.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "model_interface.h"
 #include "normalizer.h"
 #include "sentencepiece.pb.h"
@@ -996,13 +997,13 @@ TEST(SentencePieceProcessorTest, EndToEndTest) {
 
   {
     auto output = filesystem::NewWritableFile(
-        util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "model"), true);
+        util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "model"), true);
     output->Write(model_proto.SerializeAsString());
   }
 
   SentencePieceProcessor sp;
   EXPECT_TRUE(
-      sp.Load(util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "model")).ok());
+      sp.Load(util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "model")).ok());
 
   EXPECT_EQ(model_proto.SerializeAsString(),
             sp.model_proto().SerializeAsString());
@@ -1469,10 +1470,10 @@ TEST(SentencePieceProcessorTest, VocabularyTest) {
   auto GetInlineFilename = [](const std::string content) {
     {
       auto out = filesystem::NewWritableFile(
-          util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "vocab.txt"));
+          util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "vocab.txt"));
       out->Write(content);
     }
-    return util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "vocab.txt");
+    return util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "vocab.txt");
   };
 
   sp1->set_type(ModelProto::SentencePiece::UNKNOWN);
diff --git a/src/sentencepiece_trainer_test.cc b/src/sentencepiece_trainer_test.cc
index 0bb5aab..1a241b0 100644
--- a/src/sentencepiece_trainer_test.cc
+++ b/src/sentencepiece_trainer_test.cc
@@ -15,6 +15,7 @@
 #include "absl/strings/str_cat.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "sentencepiece_model.pb.h"
 #include "sentencepiece_trainer.h"
 #include "testharness.h"
@@ -51,9 +52,9 @@ void CheckNormalizer(absl::string_view filename, bool expected_has_normalizer,
 
 TEST(SentencePieceTrainerTest, TrainFromArgsTest) {
   const std::string input =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestData);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestData);
   const std::string model =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "m");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "m");
 
   ASSERT_TRUE(SentencePieceTrainer::Train(
                   absl::StrCat("--input=", input, " --model_prefix=", model,
@@ -118,9 +119,9 @@ TEST(SentencePieceTrainerTest, TrainFromIterator) {
   };
 
   const std::string input =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestData);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestData);
   const std::string model =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "m");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "m");
 
   std::vector<std::string> sentences;
   {
@@ -141,11 +142,11 @@ TEST(SentencePieceTrainerTest, TrainFromIterator) {
 
 TEST(SentencePieceTrainerTest, TrainWithCustomNormalizationRule) {
   std::string input =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestData);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestData);
   std::string rule =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kNfkcTestData);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kNfkcTestData);
   const std::string model =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "m");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "m");
 
   EXPECT_TRUE(SentencePieceTrainer::Train(
                   absl::StrCat("--input=", input, " --model_prefix=", model,
@@ -157,13 +158,13 @@ TEST(SentencePieceTrainerTest, TrainWithCustomNormalizationRule) {
 
 TEST(SentencePieceTrainerTest, TrainWithCustomDenormalizationRule) {
   const std::string input_file =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestDataJa);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestDataJa);
   const std::string model =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "m");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "m");
   const std::string norm_rule_tsv =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kIdsNormTsv);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kIdsNormTsv);
   const std::string denorm_rule_tsv =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kIdsDenormTsv);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kIdsDenormTsv);
   EXPECT_TRUE(
       SentencePieceTrainer::Train(
           absl::StrCat("--input=", input_file, " --model_prefix=", model,
@@ -186,9 +187,9 @@ TEST(SentencePieceTrainerTest, TrainErrorTest) {
 TEST(SentencePieceTrainerTest, TrainTest) {
   TrainerSpec trainer_spec;
   trainer_spec.add_input(
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestData));
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestData));
   trainer_spec.set_model_prefix(
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "m"));
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "m"));
   trainer_spec.set_vocab_size(1000);
   NormalizerSpec normalizer_spec;
   ASSERT_TRUE(SentencePieceTrainer::Train(trainer_spec, normalizer_spec).ok());
diff --git a/src/spm_decode_main.cc b/src/spm_decode_main.cc
index 32fbb76..a045823 100644
--- a/src/spm_decode_main.cc
+++ b/src/spm_decode_main.cc
@@ -21,17 +21,18 @@
 
 #include "common.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "sentencepiece.pb.h"
 #include "sentencepiece_processor.h"
 #include "util.h"
 
-ABSL_FLAG(std::string, model, "", "model file name");
-ABSL_FLAG(std::string, input, "", "input filename");
-ABSL_FLAG(std::string, output, "", "output filename");
-ABSL_FLAG(std::string, input_format, "piece", "choose from piece or id");
-ABSL_FLAG(std::string, output_format, "string", "choose from string or proto");
-ABSL_FLAG(std::string, extra_options, "",
+STPC_FLAG(std::string, model, "", "model file name");
+STPC_FLAG(std::string, input, "", "input filename");
+STPC_FLAG(std::string, output, "", "output filename");
+STPC_FLAG(std::string, input_format, "piece", "choose from piece or id");
+STPC_FLAG(std::string, output_format, "string", "choose from string or proto");
+STPC_FLAG(std::string, extra_options, "",
           "':' separated encoder extra options, e.g., \"reverse:bos:eos\"");
 
 int main(int argc, char *argv[]) {
@@ -39,25 +40,25 @@ int main(int argc, char *argv[]) {
   sentencepiece::ParseCommandLineFlags(argv[0], &argc, &argv, true);
   std::vector<std::string> rest_args;
 
-  if (absl::GetFlag(FLAGS_input).empty()) {
+  if (sentencepiece::GetFlag(FLAGS_input).empty()) {
     for (int i = 1; i < argc; ++i) {
       rest_args.push_back(std::string(argv[i]));
     }
   } else {
-    rest_args.push_back(absl::GetFlag(FLAGS_input));
+    rest_args.push_back(sentencepiece::GetFlag(FLAGS_input));
   }
 
   if (rest_args.empty())
     rest_args.push_back("");  // empty means that reading from stdin.
 
-  CHECK(!absl::GetFlag(FLAGS_model).empty());
+  CHECK(!sentencepiece::GetFlag(FLAGS_model).empty());
 
   sentencepiece::SentencePieceProcessor sp;
-  CHECK_OK(sp.Load(absl::GetFlag(FLAGS_model)));
-  CHECK_OK(sp.SetDecodeExtraOptions(absl::GetFlag(FLAGS_extra_options)));
+  CHECK_OK(sp.Load(sentencepiece::GetFlag(FLAGS_model)));
+  CHECK_OK(sp.SetDecodeExtraOptions(sentencepiece::GetFlag(FLAGS_extra_options)));
 
   auto output =
-      sentencepiece::filesystem::NewWritableFile(absl::GetFlag(FLAGS_output));
+      sentencepiece::filesystem::NewWritableFile(sentencepiece::GetFlag(FLAGS_output));
   CHECK_OK(output->status());
 
   std::string detok, line;
@@ -73,36 +74,36 @@ int main(int argc, char *argv[]) {
     return ids;
   };
 
-  if (absl::GetFlag(FLAGS_input_format) == "piece") {
-    if (absl::GetFlag(FLAGS_output_format) == "string") {
+  if (sentencepiece::GetFlag(FLAGS_input_format) == "piece") {
+    if (sentencepiece::GetFlag(FLAGS_output_format) == "string") {
       process = [&](const std::vector<std::string> &pieces) {
         CHECK_OK(sp.Decode(pieces, &detok));
         output->WriteLine(detok);
       };
-    } else if (absl::GetFlag(FLAGS_output_format) == "proto") {
+    } else if (sentencepiece::GetFlag(FLAGS_output_format) == "proto") {
       process = [&](const std::vector<std::string> &pieces) {
         CHECK_OK(sp.Decode(pieces, &spt));
       };
     } else {
       LOG(FATAL) << "Unknown output format: "
-                 << absl::GetFlag(FLAGS_output_format);
+                 << sentencepiece::GetFlag(FLAGS_output_format);
     }
-  } else if (absl::GetFlag(FLAGS_input_format) == "id") {
-    if (absl::GetFlag(FLAGS_output_format) == "string") {
+  } else if (sentencepiece::GetFlag(FLAGS_input_format) == "id") {
+    if (sentencepiece::GetFlag(FLAGS_output_format) == "string") {
       process = [&](const std::vector<std::string> &pieces) {
         CHECK_OK(sp.Decode(ToIds(pieces), &detok));
         output->WriteLine(detok);
       };
-    } else if (absl::GetFlag(FLAGS_output_format) == "proto") {
+    } else if (sentencepiece::GetFlag(FLAGS_output_format) == "proto") {
       process = [&](const std::vector<std::string> &pieces) {
         CHECK_OK(sp.Decode(ToIds(pieces), &spt));
       };
     } else {
       LOG(FATAL) << "Unknown output format: "
-                 << absl::GetFlag(FLAGS_output_format);
+                 << sentencepiece::GetFlag(FLAGS_output_format);
     }
   } else {
-    LOG(FATAL) << "Unknown input format: " << absl::GetFlag(FLAGS_input_format);
+    LOG(FATAL) << "Unknown input format: " << sentencepiece::GetFlag(FLAGS_input_format);
   }
 
   for (const auto &filename : rest_args) {
diff --git a/src/spm_encode_main.cc b/src/spm_encode_main.cc
index 02def40..b22cc7a 100644
--- a/src/spm_encode_main.cc
+++ b/src/spm_encode_main.cc
@@ -17,38 +17,38 @@
 #include <vector>
 
 #include "absl/container/flat_hash_map.h"
-#include "absl/flags/flag.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 
 #include "common.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "sentencepiece.pb.h"
 #include "sentencepiece_processor.h"
 #include "trainer_interface.h"
 
-ABSL_FLAG(std::string, model, "", "model file name");
-ABSL_FLAG(
+STPC_FLAG(std::string, model, "", "model file name");
+STPC_FLAG(
     std::string, output_format, "piece",
     "choose from piece, id, proto, nbest_piece, nbest_id, or nbest_proto");
-ABSL_FLAG(std::string, input, "", "input filename");
-ABSL_FLAG(std::string, output, "", "output filename");
-ABSL_FLAG(std::string, extra_options, "",
+STPC_FLAG(std::string, input, "", "input filename");
+STPC_FLAG(std::string, output, "", "output filename");
+STPC_FLAG(std::string, extra_options, "",
           "':' separated encoder extra options, e.g., \"reverse:bos:eos\"");
-ABSL_FLAG(int32, nbest_size, 10, "NBest size");
-ABSL_FLAG(double, alpha, 0.5, "Smoothing parameter for sampling mode.");
-ABSL_FLAG(uint32, random_seed, static_cast<uint32>(-1),
+STPC_FLAG(int32, nbest_size, 10, "NBest size");
+STPC_FLAG(double, alpha, 0.5, "Smoothing parameter for sampling mode.");
+STPC_FLAG(uint32, random_seed, static_cast<uint32>(-1),
           "Seed value for random generator.");
 
 // Piece restriction with vocabulary file.
 // https://github.com/rsennrich/subword-nmt#best-practice-advice-for-byte-pair-encoding-in-nmt
-ABSL_FLAG(std::string, vocabulary, "",
+STPC_FLAG(std::string, vocabulary, "",
           "Restrict the vocabulary. The encoder only emits the "
           "tokens in \"vocabulary\" file");
-ABSL_FLAG(int32, vocabulary_threshold, 0,
+STPC_FLAG(int32, vocabulary_threshold, 0,
           "Words with frequency < threshold will be treated as OOV");
-ABSL_FLAG(bool, generate_vocabulary, false,
+STPC_FLAG(bool, generate_vocabulary, false,
           "Generates vocabulary file instead of segmentation");
 
 int main(int argc, char *argv[]) {
@@ -56,34 +56,34 @@ int main(int argc, char *argv[]) {
   sentencepiece::ParseCommandLineFlags(argv[0], &argc, &argv, true);
   std::vector<std::string> rest_args;
 
-  if (absl::GetFlag(FLAGS_input).empty()) {
+  if (sentencepiece::GetFlag(FLAGS_input).empty()) {
     for (int i = 1; i < argc; ++i) {
       rest_args.push_back(std::string(argv[i]));
     }
   } else {
-    rest_args.push_back(absl::GetFlag(FLAGS_input));
+    rest_args.push_back(sentencepiece::GetFlag(FLAGS_input));
   }
 
-  if (absl::GetFlag(FLAGS_random_seed) != -1) {
-    sentencepiece::SetRandomGeneratorSeed(absl::GetFlag(FLAGS_random_seed));
+  if (sentencepiece::GetFlag(FLAGS_random_seed) != -1) {
+    sentencepiece::SetRandomGeneratorSeed(sentencepiece::GetFlag(FLAGS_random_seed));
   }
 
   if (rest_args.empty())
     rest_args.push_back("");  // empty means that reading from stdin.
 
-  CHECK(!absl::GetFlag(FLAGS_model).empty());
+  CHECK(!sentencepiece::GetFlag(FLAGS_model).empty());
 
   sentencepiece::SentencePieceProcessor sp;
-  CHECK_OK(sp.Load(absl::GetFlag(FLAGS_model)));
-  CHECK_OK(sp.SetEncodeExtraOptions(absl::GetFlag(FLAGS_extra_options)));
+  CHECK_OK(sp.Load(sentencepiece::GetFlag(FLAGS_model)));
+  CHECK_OK(sp.SetEncodeExtraOptions(sentencepiece::GetFlag(FLAGS_extra_options)));
 
-  if (!absl::GetFlag(FLAGS_vocabulary).empty()) {
-    CHECK_OK(sp.LoadVocabulary(absl::GetFlag(FLAGS_vocabulary),
-                               absl::GetFlag(FLAGS_vocabulary_threshold)));
+  if (!sentencepiece::GetFlag(FLAGS_vocabulary).empty()) {
+    CHECK_OK(sp.LoadVocabulary(sentencepiece::GetFlag(FLAGS_vocabulary),
+                               sentencepiece::GetFlag(FLAGS_vocabulary_threshold)));
   }
 
   auto output =
-      sentencepiece::filesystem::NewWritableFile(absl::GetFlag(FLAGS_output));
+      sentencepiece::filesystem::NewWritableFile(sentencepiece::GetFlag(FLAGS_output));
   CHECK_OK(output->status());
 
   std::string line;
@@ -96,10 +96,10 @@ int main(int argc, char *argv[]) {
   sentencepiece::NBestSentencePieceText nbest_spt;
   std::function<void(absl::string_view line)> process;
 
-  const int nbest_size = absl::GetFlag(FLAGS_nbest_size);
-  const float alpha = absl::GetFlag(FLAGS_alpha);
+  const int nbest_size = sentencepiece::GetFlag(FLAGS_nbest_size);
+  const float alpha = sentencepiece::GetFlag(FLAGS_alpha);
 
-  if (absl::GetFlag(FLAGS_generate_vocabulary)) {
+  if (sentencepiece::GetFlag(FLAGS_generate_vocabulary)) {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.Encode(line, &spt));
       for (const auto &piece : spt.pieces()) {
@@ -107,53 +107,53 @@ int main(int argc, char *argv[]) {
           vocab[piece.piece()]++;
       }
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "piece") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "piece") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.Encode(line, &sps));
       output->WriteLine(absl::StrJoin(sps, " "));
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "id") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "id") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.Encode(line, &ids));
       output->WriteLine(absl::StrJoin(ids, " "));
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "proto") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "proto") {
     process = [&](absl::string_view line) { CHECK_OK(sp.Encode(line, &spt)); };
-  } else if (absl::GetFlag(FLAGS_output_format) == "sample_piece") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "sample_piece") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.SampleEncode(line, nbest_size, alpha, &sps));
       output->WriteLine(absl::StrJoin(sps, " "));
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "sample_id") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "sample_id") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.SampleEncode(line, nbest_size, alpha, &ids));
       output->WriteLine(absl::StrJoin(ids, " "));
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "sample_proto") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "sample_proto") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.SampleEncode(line, nbest_size, alpha, &spt));
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "nbest_piece") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "nbest_piece") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.NBestEncode(line, nbest_size, &nbest_sps));
       for (const auto &result : nbest_sps) {
         output->WriteLine(absl::StrJoin(result, " "));
       }
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "nbest_id") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "nbest_id") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.NBestEncode(line, nbest_size, &nbest_ids));
       for (const auto &result : nbest_ids) {
         output->WriteLine(absl::StrJoin(result, " "));
       }
     };
-  } else if (absl::GetFlag(FLAGS_output_format) == "nbest_proto") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "nbest_proto") {
     process = [&](absl::string_view line) {
       CHECK_OK(sp.NBestEncode(line, nbest_size, &nbest_spt));
     };
   } else {
     LOG(FATAL) << "Unknown output format: "
-               << absl::GetFlag(FLAGS_output_format);
+               << sentencepiece::GetFlag(FLAGS_output_format);
   }
 
   for (const auto &filename : rest_args) {
@@ -164,7 +164,7 @@ int main(int argc, char *argv[]) {
     }
   }
 
-  if (absl::GetFlag(FLAGS_generate_vocabulary)) {
+  if (sentencepiece::GetFlag(FLAGS_generate_vocabulary)) {
     for (const auto &it : sentencepiece::Sorted(vocab)) {
       output->WriteLine(it.first + "\t" +
                         sentencepiece::string_util::SimpleItoa(it.second));
diff --git a/src/spm_export_vocab_main.cc b/src/spm_export_vocab_main.cc
index d0aea7d..c161662 100644
--- a/src/spm_export_vocab_main.cc
+++ b/src/spm_export_vocab_main.cc
@@ -14,17 +14,16 @@
 
 #include <sstream>
 
-#include "absl/flags/flag.h"
-
 #include "common.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "sentencepiece_model.pb.h"
 #include "sentencepiece_processor.h"
 
-ABSL_FLAG(std::string, output, "", "Output filename");
-ABSL_FLAG(std::string, model, "", "input model file name");
-ABSL_FLAG(std::string, output_format, "vocab",
+STPC_FLAG(std::string, output, "", "Output filename");
+STPC_FLAG(std::string, model, "", "input model file name");
+STPC_FLAG(std::string, output_format, "vocab",
           "output format. choose from vocab or syms. vocab outputs pieces "
           "and scores, syms outputs pieces and indices.");
 
@@ -33,19 +32,19 @@ int main(int argc, char *argv[]) {
   sentencepiece::ParseCommandLineFlags(argv[0], &argc, &argv, true);
 
   sentencepiece::SentencePieceProcessor sp;
-  CHECK_OK(sp.Load(absl::GetFlag(FLAGS_model)));
+  CHECK_OK(sp.Load(sentencepiece::GetFlag(FLAGS_model)));
 
   auto output =
-      sentencepiece::filesystem::NewWritableFile(absl::GetFlag(FLAGS_output));
+      sentencepiece::filesystem::NewWritableFile(sentencepiece::GetFlag(FLAGS_output));
   CHECK_OK(output->status());
 
-  if (absl::GetFlag(FLAGS_output_format) == "vocab") {
+  if (sentencepiece::GetFlag(FLAGS_output_format) == "vocab") {
     for (const auto &piece : sp.model_proto().pieces()) {
       std::ostringstream os;
       os << piece.piece() << "\t" << piece.score();
       output->WriteLine(os.str());
     }
-  } else if (absl::GetFlag(FLAGS_output_format) == "syms") {
+  } else if (sentencepiece::GetFlag(FLAGS_output_format) == "syms") {
     for (int i = 0; i < sp.model_proto().pieces_size(); i++) {
       std::ostringstream os;
       os << sp.model_proto().pieces(i).piece() << "\t" << i;
@@ -53,7 +52,7 @@ int main(int argc, char *argv[]) {
     }
   } else {
     LOG(FATAL) << "Unsupported output format: "
-               << absl::GetFlag(FLAGS_output_format);
+               << sentencepiece::GetFlag(FLAGS_output_format);
   }
 
   return 0;
diff --git a/src/spm_normalize_main.cc b/src/spm_normalize_main.cc
index 7352f63..f6fe88a 100644
--- a/src/spm_normalize_main.cc
+++ b/src/spm_normalize_main.cc
@@ -12,11 +12,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.!
 
-#include "absl/flags/flag.h"
-
 #include "builder.h"
 #include "common.h"
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "normalizer.h"
 #include "sentencepiece.pb.h"
@@ -24,20 +23,20 @@
 #include "sentencepiece_processor.h"
 #include "sentencepiece_trainer.h"
 
-ABSL_FLAG(std::string, model, "", "Model file name");
-ABSL_FLAG(bool, use_internal_normalization, false,
+STPC_FLAG(std::string, model, "", "Model file name");
+STPC_FLAG(bool, use_internal_normalization, false,
           "Use NormalizerSpec \"as-is\" to run the normalizer "
           "for SentencePiece segmentation");
-ABSL_FLAG(std::string, normalization_rule_name, "",
+STPC_FLAG(std::string, normalization_rule_name, "",
           "Normalization rule name. "
           "Choose from nfkc or identity");
-ABSL_FLAG(std::string, normalization_rule_tsv, "",
+STPC_FLAG(std::string, normalization_rule_tsv, "",
           "Normalization rule TSV file. ");
-ABSL_FLAG(bool, remove_extra_whitespaces, true, "Remove extra whitespaces");
-ABSL_FLAG(bool, decompile, false,
+STPC_FLAG(bool, remove_extra_whitespaces, true, "Remove extra whitespaces");
+STPC_FLAG(bool, decompile, false,
           "Decompile compiled charamap and output it as TSV.");
-ABSL_FLAG(std::string, input, "", "Input filename");
-ABSL_FLAG(std::string, output, "", "Output filename");
+STPC_FLAG(std::string, input, "", "Input filename");
+STPC_FLAG(std::string, output, "", "Output filename");
 
 using sentencepiece::ModelProto;
 using sentencepiece::NormalizerSpec;
@@ -51,27 +50,27 @@ int main(int argc, char *argv[]) {
   sentencepiece::ParseCommandLineFlags(argv[0], &argc, &argv, true);
   std::vector<std::string> rest_args;
 
-  if (absl::GetFlag(FLAGS_input).empty()) {
+  if (sentencepiece::GetFlag(FLAGS_input).empty()) {
     for (int i = 1; i < argc; ++i) {
       rest_args.push_back(std::string(argv[i]));
     }
   } else {
-    rest_args.push_back(absl::GetFlag(FLAGS_input));
+    rest_args.push_back(sentencepiece::GetFlag(FLAGS_input));
   }
 
   NormalizerSpec spec;
 
-  if (!absl::GetFlag(FLAGS_model).empty()) {
+  if (!sentencepiece::GetFlag(FLAGS_model).empty()) {
     ModelProto model_proto;
     SentencePieceProcessor sp;
-    CHECK_OK(sp.Load(absl::GetFlag(FLAGS_model)));
+    CHECK_OK(sp.Load(sentencepiece::GetFlag(FLAGS_model)));
     spec = sp.model_proto().normalizer_spec();
-  } else if (!absl::GetFlag(FLAGS_normalization_rule_tsv).empty()) {
+  } else if (!sentencepiece::GetFlag(FLAGS_normalization_rule_tsv).empty()) {
     spec.set_normalization_rule_tsv(
-        absl::GetFlag(FLAGS_normalization_rule_tsv));
+        sentencepiece::GetFlag(FLAGS_normalization_rule_tsv));
     CHECK_OK(SentencePieceTrainer::PopulateNormalizerSpec(&spec));
-  } else if (!absl::GetFlag(FLAGS_normalization_rule_name).empty()) {
-    spec.set_name(absl::GetFlag(FLAGS_normalization_rule_name));
+  } else if (!sentencepiece::GetFlag(FLAGS_normalization_rule_name).empty()) {
+    spec.set_name(sentencepiece::GetFlag(FLAGS_normalization_rule_name));
     CHECK_OK(SentencePieceTrainer::PopulateNormalizerSpec(&spec));
   } else {
     LOG(FATAL) << "Sets --model, normalization_rule_tsv, or "
@@ -79,22 +78,22 @@ int main(int argc, char *argv[]) {
   }
 
   // Uses the normalizer spec encoded in the model_pb.
-  if (!absl::GetFlag(FLAGS_use_internal_normalization)) {
+  if (!sentencepiece::GetFlag(FLAGS_use_internal_normalization)) {
     spec.set_add_dummy_prefix(false);    // do not add dummy prefix.
     spec.set_escape_whitespaces(false);  // do not output meta symbol.
     spec.set_remove_extra_whitespaces(
-        absl::GetFlag(FLAGS_remove_extra_whitespaces));
+        sentencepiece::GetFlag(FLAGS_remove_extra_whitespaces));
   }
 
-  if (absl::GetFlag(FLAGS_decompile)) {
+  if (sentencepiece::GetFlag(FLAGS_decompile)) {
     Builder::CharsMap chars_map;
     CHECK_OK(
         Builder::DecompileCharsMap(spec.precompiled_charsmap(), &chars_map));
-    CHECK_OK(Builder::SaveCharsMap(absl::GetFlag(FLAGS_output), chars_map));
+    CHECK_OK(Builder::SaveCharsMap(sentencepiece::GetFlag(FLAGS_output), chars_map));
   } else {
     const Normalizer normalizer(spec);
     auto output =
-        sentencepiece::filesystem::NewWritableFile(absl::GetFlag(FLAGS_output));
+        sentencepiece::filesystem::NewWritableFile(sentencepiece::GetFlag(FLAGS_output));
     CHECK_OK(output->status());
 
     if (rest_args.empty()) {
diff --git a/src/spm_train_main.cc b/src/spm_train_main.cc
index 08c519f..1e6d8a9 100644
--- a/src/spm_train_main.cc
+++ b/src/spm_train_main.cc
@@ -14,12 +14,12 @@
 
 #include <map>
 
-#include "absl/flags/flag.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/str_split.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "sentencepiece_model.pb.h"
 #include "sentencepiece_trainer.h"
@@ -33,130 +33,130 @@ static sentencepiece::TrainerSpec kDefaultTrainerSpec;
 static sentencepiece::NormalizerSpec kDefaultNormalizerSpec;
 }  // namespace
 
-ABSL_FLAG(std::string, input, "", "comma separated list of input sentences");
-ABSL_FLAG(std::string, input_format, kDefaultTrainerSpec.input_format(),
+STPC_FLAG(std::string, input, "", "comma separated list of input sentences");
+STPC_FLAG(std::string, input_format, kDefaultTrainerSpec.input_format(),
           "Input format. Supported format is `text` or `tsv`.");
-ABSL_FLAG(std::string, model_prefix, "", "output model prefix");
-ABSL_FLAG(std::string, model_type, "unigram",
+STPC_FLAG(std::string, model_prefix, "", "output model prefix");
+STPC_FLAG(std::string, model_type, "unigram",
           "model algorithm: unigram, bpe, word or char");
-ABSL_FLAG(int32, vocab_size, kDefaultTrainerSpec.vocab_size(),
+STPC_FLAG(int32, vocab_size, kDefaultTrainerSpec.vocab_size(),
           "vocabulary size");
-ABSL_FLAG(std::string, accept_language, "",
+STPC_FLAG(std::string, accept_language, "",
           "comma-separated list of languages this model can accept");
-ABSL_FLAG(int32, self_test_sample_size,
+STPC_FLAG(int32, self_test_sample_size,
           kDefaultTrainerSpec.self_test_sample_size(),
           "the size of self test samples");
-ABSL_FLAG(double, character_coverage, kDefaultTrainerSpec.character_coverage(),
+STPC_FLAG(double, character_coverage, kDefaultTrainerSpec.character_coverage(),
           "character coverage to determine the minimum symbols");
-ABSL_FLAG(std::uint64_t, input_sentence_size,
+STPC_FLAG(std::uint64_t, input_sentence_size,
           kDefaultTrainerSpec.input_sentence_size(),
           "maximum size of sentences the trainer loads");
-ABSL_FLAG(bool, shuffle_input_sentence,
+STPC_FLAG(bool, shuffle_input_sentence,
           kDefaultTrainerSpec.shuffle_input_sentence(),
           "Randomly sample input sentences in advance. Valid when "
           "--input_sentence_size > 0");
-ABSL_FLAG(int32, seed_sentencepiece_size,
+STPC_FLAG(int32, seed_sentencepiece_size,
           kDefaultTrainerSpec.seed_sentencepiece_size(),
           "the size of seed sentencepieces");
-ABSL_FLAG(double, shrinking_factor, kDefaultTrainerSpec.shrinking_factor(),
+STPC_FLAG(double, shrinking_factor, kDefaultTrainerSpec.shrinking_factor(),
           "Keeps top shrinking_factor pieces with respect to the loss");
-ABSL_FLAG(int32, num_threads, kDefaultTrainerSpec.num_threads(),
+STPC_FLAG(int32, num_threads, kDefaultTrainerSpec.num_threads(),
           "number of threads for training");
-ABSL_FLAG(int32, num_sub_iterations, kDefaultTrainerSpec.num_sub_iterations(),
+STPC_FLAG(int32, num_sub_iterations, kDefaultTrainerSpec.num_sub_iterations(),
           "number of EM sub-iterations");
-ABSL_FLAG(int32, max_sentencepiece_length,
+STPC_FLAG(int32, max_sentencepiece_length,
           kDefaultTrainerSpec.max_sentencepiece_length(),
           "maximum length of sentence piece");
-ABSL_FLAG(int32, max_sentence_length, kDefaultTrainerSpec.max_sentence_length(),
+STPC_FLAG(int32, max_sentence_length, kDefaultTrainerSpec.max_sentence_length(),
           "maximum length of sentence in byte");
-ABSL_FLAG(bool, split_by_unicode_script,
+STPC_FLAG(bool, split_by_unicode_script,
           kDefaultTrainerSpec.split_by_unicode_script(),
           "use Unicode script to split sentence pieces");
-ABSL_FLAG(bool, split_by_number, kDefaultTrainerSpec.split_by_number(),
+STPC_FLAG(bool, split_by_number, kDefaultTrainerSpec.split_by_number(),
           "split tokens by numbers (0-9)");
-ABSL_FLAG(bool, split_by_whitespace, kDefaultTrainerSpec.split_by_whitespace(),
+STPC_FLAG(bool, split_by_whitespace, kDefaultTrainerSpec.split_by_whitespace(),
           "use a white space to split sentence pieces");
-ABSL_FLAG(bool, split_digits, kDefaultTrainerSpec.split_digits(),
+STPC_FLAG(bool, split_digits, kDefaultTrainerSpec.split_digits(),
           "split all digits (0-9) into separate pieces");
-ABSL_FLAG(std::string, pretokenization_delimiter,
+STPC_FLAG(std::string, pretokenization_delimiter,
           kDefaultTrainerSpec.pretokenization_delimiter(),
           "specifies the delimiter of pre-tokenization");
-ABSL_FLAG(bool, treat_whitespace_as_suffix,
+STPC_FLAG(bool, treat_whitespace_as_suffix,
           kDefaultTrainerSpec.treat_whitespace_as_suffix(),
           "treat whitespace marker as suffix instead of prefix.");
-ABSL_FLAG(bool, allow_whitespace_only_pieces,
+STPC_FLAG(bool, allow_whitespace_only_pieces,
           kDefaultTrainerSpec.allow_whitespace_only_pieces(),
           "allow pieces that only contain (consecutive) whitespace tokens");
-ABSL_FLAG(std::string, control_symbols, "",
+STPC_FLAG(std::string, control_symbols, "",
           "comma separated list of control symbols");
-ABSL_FLAG(std::string, control_symbols_file, "",
+STPC_FLAG(std::string, control_symbols_file, "",
           "load control_symbols from file.");
-ABSL_FLAG(std::string, user_defined_symbols, "",
+STPC_FLAG(std::string, user_defined_symbols, "",
           "comma separated list of user defined symbols");
-ABSL_FLAG(std::string, user_defined_symbols_file, "",
+STPC_FLAG(std::string, user_defined_symbols_file, "",
           "load user_defined_symbols from file.");
-ABSL_FLAG(std::string, required_chars, "",
+STPC_FLAG(std::string, required_chars, "",
           "UTF8 characters in this flag are always used in the character "
           "set regardless of --character_coverage");
-ABSL_FLAG(std::string, required_chars_file, "",
+STPC_FLAG(std::string, required_chars_file, "",
           "load required_chars from file.");
-ABSL_FLAG(bool, byte_fallback, kDefaultTrainerSpec.byte_fallback(),
+STPC_FLAG(bool, byte_fallback, kDefaultTrainerSpec.byte_fallback(),
           "decompose unknown pieces into UTF-8 byte pieces");
-ABSL_FLAG(bool, vocabulary_output_piece_score,
+STPC_FLAG(bool, vocabulary_output_piece_score,
           kDefaultTrainerSpec.vocabulary_output_piece_score(),
           "Define score in vocab file");
-ABSL_FLAG(std::string, normalization_rule_name, "nmt_nfkc",
+STPC_FLAG(std::string, normalization_rule_name, "nmt_nfkc",
           "Normalization rule name. "
           "Choose from nfkc or identity");
-ABSL_FLAG(std::string, normalization_rule_tsv, "",
+STPC_FLAG(std::string, normalization_rule_tsv, "",
           "Normalization rule TSV file. ");
-ABSL_FLAG(std::string, denormalization_rule_tsv, "",
+STPC_FLAG(std::string, denormalization_rule_tsv, "",
           "Denormalization rule TSV file.");
-ABSL_FLAG(bool, add_dummy_prefix, kDefaultNormalizerSpec.add_dummy_prefix(),
+STPC_FLAG(bool, add_dummy_prefix, kDefaultNormalizerSpec.add_dummy_prefix(),
           "Add dummy whitespace at the beginning of text");
-ABSL_FLAG(bool, remove_extra_whitespaces,
+STPC_FLAG(bool, remove_extra_whitespaces,
           kDefaultNormalizerSpec.remove_extra_whitespaces(),
           "Removes leading, trailing, and "
           "duplicate internal whitespace");
-ABSL_FLAG(bool, hard_vocab_limit, kDefaultTrainerSpec.hard_vocab_limit(),
+STPC_FLAG(bool, hard_vocab_limit, kDefaultTrainerSpec.hard_vocab_limit(),
           "If set to false, --vocab_size is considered as a soft limit.");
-ABSL_FLAG(bool, use_all_vocab, kDefaultTrainerSpec.use_all_vocab(),
+STPC_FLAG(bool, use_all_vocab, kDefaultTrainerSpec.use_all_vocab(),
           "If set to true, use all tokens as vocab. "
           "Valid for word/char models.");
-ABSL_FLAG(int32, unk_id, kDefaultTrainerSpec.unk_id(),
+STPC_FLAG(int32, unk_id, kDefaultTrainerSpec.unk_id(),
           "Override UNK (<unk>) id.");
-ABSL_FLAG(int32, bos_id, kDefaultTrainerSpec.bos_id(),
+STPC_FLAG(int32, bos_id, kDefaultTrainerSpec.bos_id(),
           "Override BOS (<s>) id. Set -1 to disable BOS.");
-ABSL_FLAG(int32, eos_id, kDefaultTrainerSpec.eos_id(),
+STPC_FLAG(int32, eos_id, kDefaultTrainerSpec.eos_id(),
           "Override EOS (</s>) id. Set -1 to disable EOS.");
-ABSL_FLAG(int32, pad_id, kDefaultTrainerSpec.pad_id(),
+STPC_FLAG(int32, pad_id, kDefaultTrainerSpec.pad_id(),
           "Override PAD (<pad>) id. Set -1 to disable PAD.");
-ABSL_FLAG(std::string, unk_piece, kDefaultTrainerSpec.unk_piece(),
+STPC_FLAG(std::string, unk_piece, kDefaultTrainerSpec.unk_piece(),
           "Override UNK (<unk>) piece.");
-ABSL_FLAG(std::string, bos_piece, kDefaultTrainerSpec.bos_piece(),
+STPC_FLAG(std::string, bos_piece, kDefaultTrainerSpec.bos_piece(),
           "Override BOS (<s>) piece.");
-ABSL_FLAG(std::string, eos_piece, kDefaultTrainerSpec.eos_piece(),
+STPC_FLAG(std::string, eos_piece, kDefaultTrainerSpec.eos_piece(),
           "Override EOS (</s>) piece.");
-ABSL_FLAG(std::string, pad_piece, kDefaultTrainerSpec.pad_piece(),
+STPC_FLAG(std::string, pad_piece, kDefaultTrainerSpec.pad_piece(),
           "Override PAD (<pad>) piece.");
-ABSL_FLAG(std::string, unk_surface, kDefaultTrainerSpec.unk_surface(),
+STPC_FLAG(std::string, unk_surface, kDefaultTrainerSpec.unk_surface(),
           "Dummy surface string for <unk>. In decoding <unk> is decoded to "
           "`unk_surface`.");
-ABSL_FLAG(bool, train_extremely_large_corpus,
+STPC_FLAG(bool, train_extremely_large_corpus,
           kDefaultTrainerSpec.train_extremely_large_corpus(),
           "Increase bit depth for unigram tokenization.");
-ABSL_FLAG(uint32, random_seed, static_cast<uint32>(-1),
+STPC_FLAG(uint32, random_seed, static_cast<uint32>(-1),
           "Seed value for random generator.");
 
 // DP related.
-ABSL_FLAG(bool, enable_differential_privacy, false,
+STPC_FLAG(bool, enable_differential_privacy, false,
           "Whether to add DP while training. Currently supported only by "
           "UNIGRAM model.");
 
-ABSL_FLAG(float, differential_privacy_noise_level, 0.0f,
+STPC_FLAG(float, differential_privacy_noise_level, 0.0f,
           "Amount of noise to add for"
           " DP");
-ABSL_FLAG(std::uint64_t, differential_privacy_clipping_threshold, 0,
+STPC_FLAG(std::uint64_t, differential_privacy_clipping_threshold, 0,
           "Threshold for"
           " clipping the counts for DP");
 
@@ -168,11 +168,11 @@ int main(int argc, char *argv[]) {
   sentencepiece::NormalizerSpec normalizer_spec;
   NormalizerSpec denormalizer_spec;
 
-  CHECK(!absl::GetFlag(FLAGS_input).empty());
-  CHECK(!absl::GetFlag(FLAGS_model_prefix).empty());
+  CHECK(!sentencepiece::GetFlag(FLAGS_input).empty());
+  CHECK(!sentencepiece::GetFlag(FLAGS_model_prefix).empty());
 
-  if (absl::GetFlag(FLAGS_random_seed) != -1) {
-    sentencepiece::SetRandomGeneratorSeed(absl::GetFlag(FLAGS_random_seed));
+  if (sentencepiece::GetFlag(FLAGS_random_seed) != -1) {
+    sentencepiece::SetRandomGeneratorSeed(sentencepiece::GetFlag(FLAGS_random_seed));
   }
 
   auto load_lines = [](absl::string_view filename) {
@@ -186,28 +186,28 @@ int main(int argc, char *argv[]) {
 
 // Populates the value from flags to spec.
 #define SetTrainerSpecFromFlag(name) \
-  trainer_spec.set_##name(absl::GetFlag(FLAGS_##name));
+  trainer_spec.set_##name(sentencepiece::GetFlag(FLAGS_##name));
 
 #define SetNormalizerSpecFromFlag(name) \
-  normalizer_spec.set_##name(absl::GetFlag(FLAGS_##name));
+  normalizer_spec.set_##name(sentencepiece::GetFlag(FLAGS_##name));
 
 #define SetTrainerSpecFromFile(name)                                   \
-  if (!absl::GetFlag(FLAGS_##name##_file).empty()) {                   \
-    const auto lines = load_lines(absl::GetFlag(FLAGS_##name##_file)); \
+  if (!sentencepiece::GetFlag(FLAGS_##name##_file).empty()) {          \
+    const auto lines = load_lines(sentencepiece::GetFlag(FLAGS_##name##_file)); \
     trainer_spec.set_##name(absl::StrJoin(lines, ""));                 \
   }
 
 #define SetRepeatedTrainerSpecFromFlag(name)                                \
-  if (!absl::GetFlag(FLAGS_##name).empty()) {                               \
+  if (!sentencepiece::GetFlag(FLAGS_##name).empty()) {                      \
     for (const auto &v :                                                    \
-         sentencepiece::util::StrSplitAsCSV(absl::GetFlag(FLAGS_##name))) { \
+         sentencepiece::util::StrSplitAsCSV(sentencepiece::GetFlag(FLAGS_##name))) { \
       trainer_spec.add_##name(v);                                           \
     }                                                                       \
   }
 
 #define SetRepeatedTrainerSpecFromFile(name)                               \
-  if (!absl::GetFlag(FLAGS_##name##_file).empty()) {                       \
-    for (const auto &v : load_lines(absl::GetFlag(FLAGS_##name##_file))) { \
+  if (!sentencepiece::GetFlag(FLAGS_##name##_file).empty()) {              \
+    for (const auto &v : load_lines(sentencepiece::GetFlag(FLAGS_##name##_file))) { \
       trainer_spec.add_##name(v);                                          \
     }                                                                      \
   }
@@ -261,21 +261,21 @@ int main(int argc, char *argv[]) {
   SetRepeatedTrainerSpecFromFile(control_symbols);
   SetRepeatedTrainerSpecFromFile(user_defined_symbols);
 
-  normalizer_spec.set_name(absl::GetFlag(FLAGS_normalization_rule_name));
+  normalizer_spec.set_name(sentencepiece::GetFlag(FLAGS_normalization_rule_name));
   SetNormalizerSpecFromFlag(normalization_rule_tsv);
   SetNormalizerSpecFromFlag(add_dummy_prefix);
   SetNormalizerSpecFromFlag(remove_extra_whitespaces);
 
-  if (!absl::GetFlag(FLAGS_denormalization_rule_tsv).empty()) {
+  if (!sentencepiece::GetFlag(FLAGS_denormalization_rule_tsv).empty()) {
     denormalizer_spec.set_normalization_rule_tsv(
-        absl::GetFlag(FLAGS_denormalization_rule_tsv));
+        sentencepiece::GetFlag(FLAGS_denormalization_rule_tsv));
     denormalizer_spec.set_add_dummy_prefix(false);
     denormalizer_spec.set_remove_extra_whitespaces(false);
     denormalizer_spec.set_escape_whitespaces(false);
   }
 
   CHECK_OK(sentencepiece::SentencePieceTrainer::PopulateModelTypeFromString(
-      absl::GetFlag(FLAGS_model_type), &trainer_spec));
+      sentencepiece::GetFlag(FLAGS_model_type), &trainer_spec));
 
   CHECK_OK(sentencepiece::SentencePieceTrainer::Train(
       trainer_spec, normalizer_spec, denormalizer_spec));
diff --git a/src/test_main.cc b/src/test_main.cc
index 38c978d..f9cf694 100644
--- a/src/test_main.cc
+++ b/src/test_main.cc
@@ -12,16 +12,17 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.!
 
+#include "glue/flags/flag.h"
 #include "init.h"
 #include "testharness.h"
 
 #ifdef OS_WIN
-ABSL_FLAG(std::string, test_srcdir, "..\\data", "Data directory.");
+STPC_FLAG(std::string, test_srcdir, "..\\data", "Data directory.");
 #else
-ABSL_FLAG(std::string, test_srcdir, "../data", "Data directory.");
+STPC_FLAG(std::string, test_srcdir, "../data", "Data directory.");
 #endif
 
-ABSL_FLAG(std::string, test_tmpdir, "test_tmp", "Temporary directory.");
+STPC_FLAG(std::string, test_tmpdir, "test_tmp", "Temporary directory.");
 
 int main(int argc, char **argv) {
   sentencepiece::ScopedResourceDestructor cleaner;
diff --git a/src/testharness.cc b/src/testharness.cc
index 6769cd8..d9a84d2 100644
--- a/src/testharness.cc
+++ b/src/testharness.cc
@@ -28,6 +28,7 @@
 #include "absl/strings/str_cat.h"
 
 #include "common.h"
+#include "glue/flags/flag.h"
 #include "util.h"
 
 namespace sentencepiece {
@@ -57,9 +58,9 @@ bool RegisterTest(const char *base, const char *name, void (*func)()) {
 int RunAllTests() {
   int num = 0;
 #ifdef OS_WIN
-  _mkdir(absl::GetFlag(FLAGS_test_tmpdir).c_str());
+  _mkdir(sentencepiece::GetFlag(FLAGS_test_tmpdir).c_str());
 #else
-  mkdir(absl::GetFlag(FLAGS_test_tmpdir).c_str(), S_IRUSR | S_IWUSR | S_IXUSR);
+  mkdir(sentencepiece::GetFlag(FLAGS_test_tmpdir).c_str(), S_IRUSR | S_IWUSR | S_IXUSR);
 #endif
 
   if (tests == nullptr) {
diff --git a/src/testharness.h b/src/testharness.h
index 8de9c5c..022325d 100644
--- a/src/testharness.h
+++ b/src/testharness.h
@@ -20,14 +20,14 @@
 #include <sstream>
 #include <string>
 
-#include "absl/flags/flag.h"
-#include "absl/flags/parse.h"
 #include "absl/strings/string_view.h"
 
 #include "common.h"
+#include "glue/flags/flag.h"
+#include "glue/flags/parse.h"
 
-ABSL_DECLARE_FLAG(std::string, test_tmpdir);
-ABSL_DECLARE_FLAG(std::string, test_srcdir);
+STPC_DECLARE_FLAG(std::string, test_tmpdir);
+STPC_DECLARE_FLAG(std::string, test_srcdir);
 
 namespace sentencepiece {
 namespace test {
diff --git a/src/trainer_interface.cc b/src/trainer_interface.cc
index 27cec4f..e9e1cd2 100644
--- a/src/trainer_interface.cc
+++ b/src/trainer_interface.cc
@@ -24,8 +24,6 @@
 
 #include "absl/container/flat_hash_map.h"
 #include "absl/memory/memory.h"
-#include "absl/random/distributions.h"
-#include "absl/random/random.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -33,6 +31,8 @@
 #include "absl/strings/str_split.h"
 
 #include "filesystem.h"
+#include "glue/random/distributions.h"
+#include "glue/random/random.h"
 #include "model_factory.h"
 #include "model_interface.h"
 #include "normalizer.h"
@@ -304,10 +304,10 @@ bool TrainerInterface::IsValidSentencePiece(
 }
 
 template <typename T>
-void AddDPNoise(const TrainerSpec &trainer_spec, absl::SharedBitGen &generator,
+void AddDPNoise(const TrainerSpec &trainer_spec, sentencepiece::SharedBitGen &generator,
                 T *to_update) {
   if (trainer_spec.differential_privacy_noise_level() > 0) {
-    float random_num = absl::Gaussian<float>(
+    float random_num = sentencepiece::Gaussian<float>(
         generator, 0, trainer_spec.differential_privacy_noise_level());
 
     *to_update =
@@ -481,7 +481,7 @@ END:
       for (int n = 0; n < num_workers; ++n) {
         pool->Schedule([&, n]() {
           // One per thread generator.
-          absl::SharedBitGen generator;
+          sentencepiece::SharedBitGen generator;
           for (size_t i = n; i < sentences_.size(); i += num_workers) {
             AddDPNoise<int64>(trainer_spec_, generator,
                               &(sentences_[i].second));
diff --git a/src/trainer_interface_test.cc b/src/trainer_interface_test.cc
index 75e9f54..ca4d4e7 100644
--- a/src/trainer_interface_test.cc
+++ b/src/trainer_interface_test.cc
@@ -20,6 +20,7 @@
 #include "absl/strings/str_format.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "testharness.h"
 #include "util.h"
 
@@ -494,7 +495,7 @@ TEST(TrainerInterfaceTest, SerializeTest) {
 
 TEST(TrainerInterfaceTest, CharactersTest) {
   const std::string input_file =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "input");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "input");
   {
     auto output = filesystem::NewWritableFile(input_file);
     // Make a single line with 50 "a", 49 "あ", and 1 "b".
@@ -560,7 +561,7 @@ TEST(TrainerInterfaceTest, MultiFileSentenceIteratorTest) {
   std::vector<std::string> files;
   std::vector<std::string> expected;
   for (int i = 0; i < 10; ++i) {
-    const std::string file = util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir),
+    const std::string file = util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir),
                                             absl::StrCat("input", i));
     auto output = filesystem::NewWritableFile(file);
     int num_line = (rand() % 100) + 1;
@@ -582,7 +583,7 @@ TEST(TrainerInterfaceTest, MultiFileSentenceIteratorTest) {
 TEST(TrainerInterfaceTest, MultiFileSentenceIteratorErrorTest) {
   std::vector<std::string> files;
   for (int i = 0; i < 10; ++i) {
-    const std::string file = util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir),
+    const std::string file = util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir),
                                             absl::StrCat("input_not_exist", i));
     files.push_back(file);
   }
diff --git a/src/unigram_model_trainer_test.cc b/src/unigram_model_trainer_test.cc
index ab887b6..f1c465b 100644
--- a/src/unigram_model_trainer_test.cc
+++ b/src/unigram_model_trainer_test.cc
@@ -21,6 +21,7 @@
 #include "absl/strings/str_join.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "sentencepiece_model.pb.h"
 #include "sentencepiece_processor.h"
 #include "sentencepiece_trainer.h"
@@ -49,9 +50,9 @@ TrainerResult RunTrainer(const std::vector<std::string>& input, int size,
                          const bool use_dp = false, const float dp_noise = 0.0,
                          const uint32 dp_clip = 0) {
   const std::string input_file =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "input");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "input");
   const std::string model_prefix =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "model");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "model");
   {
     auto output = filesystem::NewWritableFile(input_file);
     for (const auto& line : input) {
@@ -156,13 +157,13 @@ static constexpr char kTestInputData[] = "wagahaiwa_nekodearu.txt";
 
 TEST(UnigramTrainerTest, EndToEndTest) {
   const std::string input =
-      util::JoinPath(absl::GetFlag(FLAGS_test_srcdir), kTestInputData);
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_srcdir), kTestInputData);
 
   ASSERT_TRUE(
       SentencePieceTrainer::Train(
           absl::StrCat(
               "--model_prefix=",
-              util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "tmp_model"),
+              util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "tmp_model"),
               " --input=", input,
               " --vocab_size=8000 --normalization_rule_name=identity",
               " --model_type=unigram --user_defined_symbols=<user>",
@@ -170,7 +171,7 @@ TEST(UnigramTrainerTest, EndToEndTest) {
           .ok());
 
   SentencePieceProcessor sp;
-  EXPECT_TRUE(sp.Load(util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir),
+  EXPECT_TRUE(sp.Load(util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir),
                                      "tmp_model.model"))
                   .ok());
   EXPECT_EQ(8000, sp.GetPieceSize());
diff --git a/src/util_test.cc b/src/util_test.cc
index e264081..837cca4 100644
--- a/src/util_test.cc
+++ b/src/util_test.cc
@@ -17,6 +17,7 @@
 #include "absl/strings/str_cat.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "testharness.h"
 #include "util.h"
 
@@ -333,7 +334,7 @@ TEST(UtilTest, InputOutputBufferTest) {
 
   {
     auto output = filesystem::NewWritableFile(
-        util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test_file"));
+        util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test_file"));
     for (size_t i = 0; i < kData.size(); ++i) {
       output->WriteLine(kData[i]);
     }
@@ -341,7 +342,7 @@ TEST(UtilTest, InputOutputBufferTest) {
 
   {
     auto input = filesystem::NewReadableFile(
-        util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "test_file"));
+        util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "test_file"));
     std::string line;
     for (size_t i = 0; i < kData.size(); ++i) {
       EXPECT_TRUE(input->ReadLine(&line));
diff --git a/src/word_model_trainer_test.cc b/src/word_model_trainer_test.cc
index 8288027..ab55030 100644
--- a/src/word_model_trainer_test.cc
+++ b/src/word_model_trainer_test.cc
@@ -19,6 +19,7 @@
 #include "absl/strings/str_join.h"
 
 #include "filesystem.h"
+#include "glue/flags/flag.h"
 #include "sentencepiece_processor.h"
 #include "testharness.h"
 #include "util.h"
@@ -33,9 +34,9 @@ namespace {
 
 std::string RunTrainer(const std::vector<std::string> &input, int size) {
   const std::string input_file =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "input");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "input");
   const std::string model_prefix =
-      util::JoinPath(absl::GetFlag(FLAGS_test_tmpdir), "model");
+      util::JoinPath(sentencepiece::GetFlag(FLAGS_test_tmpdir), "model");
   {
     auto output = filesystem::NewWritableFile(input_file);
     for (const auto &line : input) {
